---
title: "Project2"
author: "Terry"
date: "2023-11-06"
output: html_document
---
```{r}
remove(list=ls())

## water quality data, is_safe is a binary variable 0 or 1
# ammonia is incorrectly labeled as character
water = read.csv("waterQuality1.csv", header = TRUE)
summary(water)
water$ammonia = as.numeric(water$ammonia)
water$is_safe = as.numeric(water$is_safe)
water = na.omit(water)
water$is_safe = as.factor(water$is_safe)
summary(water)
water$ammonia[which(water$ammonia < 0)] = NA
water = na.omit(water)
summary(water)
dim(water)
```

```{r}

### first fit a logistic regression
library(nnet)
library(MASS)
### need to rescale
rescale <- function(x1, x2) {
  for (col in 1:ncol(x1)) {
    a <- min(x2[, col])
    b <- max(x2[, col])
    x1[, col] <- (x1[, col] - a) / (b - a)
  }
  x1
}

p.train <- 0.75
n <- nrow(water)
n.train <- floor(p.train * n)

ind.random <- sample(1:n)
data.train <- water[ind.random <= n.train, ]
data.valid <- water[ind.random > n.train, ]
Y.valid <- data.valid[, 21]

data.train.scale <- data.train
data.valid.scale <- data.valid
data.train.scale[, -21] <- rescale(data.train.scale[, -21], data.train[, -21])
data.valid.scale[, -21] <- rescale(data.valid.scale[, -21], data.train[, -21])

X.train.scale <- as.matrix(data.train.scale[, -21])
Y.train <- data.train.scale[, 21]
X.valid.scale <- as.matrix(data.valid.scale[, -21])
Y.valid <- data.valid.scale[, 21]

fit.log.nnet <- multinom(is_safe ~ ., data = data.train.scale)
summary(fit.log.nnet)

### Next, let's investigate the LR's performance on the test set
## probabilities
pred.log.nnet.probs <- predict(fit.log.nnet, data.valid.scale, type = 'probs')

pred.log.nnet <- predict(fit.log.nnet, data.valid.scale)
table(Y.valid, pred.log.nnet, ### Confusion matrix
  dnn = c("Observed", "Predicted")
)

(misclass.log.nnet <- mean(pred.log.nnet != Y.valid)) ### Misclass rate

## misclass rate is about 10%
## now to LDR

### For discriminant analysis, it's best to scale predictors
### to have mean 0 and SD 1 (this makes the results easier to
### interpret). We can do this using using the following function.

### Rescale x1 using the means and SDs of x2
scale.1 <- function(x1, x2) {
  for (col in 1:ncol(x1)) {
    a <- mean(x2[, col])
    b <- sd(x2[, col])
    x1[, col] <- (x1[, col] - a) / b
  }
  x1
}

X.train.DA <- scale.1(data.train[, -21], data.train[, -21])
X.valid.DA <- scale.1(data.valid[, -21], data.train[, -21])

### Fit an LDA model using the lda() funtion from the MASS package. This
### function uses predictor/response syntax.
fit.lda <- lda(X.train.DA, Y.train)

### We get predictions by extracting the class object from the predict()
### function's output.

## this gets the probability of predicting a 1
pred.lda.probs <- (predict(fit.lda, X.valid.DA)$posterior)[,2]
pred.lda <- predict(fit.lda, X.valid.DA)$class

table(Y.valid, pred.lda, dnn = c("Obs", "Pred"))

(miss.lda <- mean(Y.valid != pred.lda))

```

```{r}
### attempting ROC Curve
library(ROCR)
rocplot =function(pred, truth, ...){
  predob = prediction(pred, truth)
  perf = performance (predob, "tpr", "fpr")
  plot(perf,...)}
rocplot(pred.log.nnet.probs, Y.valid, main = "Logistic Regression ROC Curve")
(performance(prediction(pred.log.nnet.probs, Y.valid), measure = "auc"))@y.values[[1]]
rocplot(pred.lda.probs, Y.valid, main = "Linear Discriminant ROC Curve")
(performance(prediction(pred.lda.probs, Y.valid), measure = "auc"))@y.values[[1]]
```

```{r}
### attempting SVM
library(e1071)
set.seed(1)

## cost = 1
svmfit = svm(is_safe ~., data=data.train, kernel = "radial", gamma = 1, cost=1)
summary(svmfit)

## cost = 1e5
svmfit2 = svm(is_safe ~., data=data.train, kernel = "radial", gamma = 1, cost=1e5)
summary(svmfit2)

tune.out=tune(svm, is_safe ~., data=data.train, kernel = "radial",
              ranges =list(cost=c(0.1 ,1 ,10 ,100 ,1000),
                           gamma=c(0.5,1,2,3,4) ))
summary(tune.out)

## select best SVM model
table(true=Y.valid, pred=predict(tune.out$best.model,
newdata = data.valid))

## ROC Curve
svmfit.opt= svm(is_safe ~., data=data.train, kernel = "radial",
gamma = 2, cost = 1, decision.values = T)
fitted =attributes(predict(svmfit.opt, data.valid, decision.values=TRUE))$decision.values
rocplot(fitted, Y.valid, main = "SVM")
(performance(prediction(fitted, Y.valid), measure = "auc"))@y.values[[1]]
```

