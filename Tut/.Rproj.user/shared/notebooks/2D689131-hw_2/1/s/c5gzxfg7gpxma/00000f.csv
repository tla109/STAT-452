"0","library(pls)"
"2","
Attaching package: ‘pls’

"
"2","The following object is masked from ‘package:stats’:

    loadings

"
"0","all.MSPEs.pls <- array(0, dim = c(K, 1))"
"0","colnames(all.MSPEs.pls) <- c(""PLS"")"
"0",""
"0","n_comps = array(0, dim = c(K,1))"
"0",""
"0","for (i in 1:K) {"
"0","  ### Split data"
"0","  data.train <- AQ[folds != i, ]"
"0","  data.valid <- AQ[folds == i, ]"
"0","  n.train <- nrow(data.train)"
"0",""
"0","  ### Get response vectors"
"0","  Y.train <- data.train$Ozone"
"0","  Y.valid <- data.valid$Ozone"
"0",""
"0","  ### Now, let's do PLS using the plsr() function. The syntax is"
"0","  ### very similar to lm(). If we set validation = ""CV"", the plsr()"
"0","  ### function will do its own internal CV, and give MSPEs for each"
"0","  ### number of components. We can then use this to choose how many"
"0","  ### componenets to keep when doing prediction on the validation"
"0","  ### fold. We can use an optional input called segments to specify"
"0","  ### how many folds we want plsr() to use for its internal CV"
"0","  ### (default is 10)."
"0","  fit_pls <- plsr(Ozone ~ .,"
"0","    data = data.train, validation = ""CV"")"
"0",""
"0","  ### Investigate the fitted PLS model. Comment out the next two"
"0","  ### lines when running a CV loop"
"0",""
"0","  ### The summary function gives us lots of information about how"
"0","  ### errors change as we increase the number of components"
"0","  # summary(fit.pls)"
"0",""
"0","  ### The validationplot() function shows how MSPE from the internal"
"0","  ### CV of plsr() changes with the number of included components."
"0","  # validationplot(fit.pls)"
"0",""
"0","  ### Get the best model from PLS. To do this, we need to find the model"
"0","  ### that minimizes MSPE for the plsr() function's internal CV. It"
"0","  ### takes a few steps, but all the information we need is contained"
"0","  ### in the output of plsr()."
"0","  CV_pls <- fit_pls$validation"
"0","  pls_comps <- CV_pls$PRESS"
"0","  n_comps[i] <- which.min(pls_comps)"
"0",""
"0","  ### Get predictions and calculate MSPE on the validation fold"
"0","  ### Set ncomps equal to the optimal number of components"
"0","  pred.pls <- predict(fit_pls, data.valid, ncomp = n_comps[i])"
"0","  MSPE.pls <- get.MSPE(Y.valid, pred.pls)"
"0","  all.MSPEs.pls[i, ""PLS""] <- MSPE.pls"
"0","}"
"0",""
"0","n_comps"
"1","     "
"1"," [,1]"
"1","
 [1,]"
"1","    5"
"1","
 [2,]"
"1","    3"
"1","
 [3,]"
"1","    3"
"1","
 [4,]"
"1","    3"
"1","
 [5,]"
"1","    3"
"1","
 [6,]"
"1","    3"
"1","
 [7,]"
"1","    3"
"1","
 [8,]"
"1","    3"
"1","
 [9,]"
"1","    5"
"1","
[10,]"
"1","    3"
"1","
"
"0","all.MSPEs.pls"
"1","     "
"1","       PLS"
"1","
 [1,]"
"1","  260.4455"
"1","
 [2,]"
"1","  139.8033"
"1","
 [3,]"
"1","  513.6342"
"1","
 [4,]"
"1","  137.6674"
"1","
 [5,]"
"1","  146.0280"
"1","
 [6,]"
"1","  417.0061"
"1","
 [7,]"
"1","  265.6754"
"1","
 [8,]"
"1","  655.6349"
"1","
 [9,]"
"1"," 1055.8045"
"1","
[10,]"
"1","  699.0148"
"1","
"
"0","mean(all.MSPEs.pls)"
"1","[1]"
"1"," 429.0714"
"1","
"
