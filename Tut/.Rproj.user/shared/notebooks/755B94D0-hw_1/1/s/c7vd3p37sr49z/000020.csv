"0","### We need to divide the dataset into 5 folds."
"0","### We can do this by randomly sampling the numbers from 1 to 10 and"
"0","### attaching these to our dataset as fold labels"
"0","M = 5"
"0","n.fold <- n / M # Number of observations in each fold"
"0","n.fold <- ceiling(n.fold) # Round up to make sure we get enough labels"
"0","# We can remove any excess later"
"0","ordered.ids <- rep(1:M, times = n.fold)"
"0","ordered.ids <- ordered.ids[1:n] # Remove excess label(s)"
"0","shuffle <- sample.int(n) # Randomly permute the numbers 1 to n"
"0","shuffled.ids <- ordered.ids[shuffle] # Use shuffle to permute"
"0","# the fold labels"
"0","data.CV <- AQ # Create a copy of our dataset"
"0","data.CV$fold <- shuffled.ids # Add a column to our new dataset containing"
"0","# the fold labels"
"0",""
"0",""
"0","### Next, let's actually do the cross validation. This will be easier"
"0","### with a for loop than with the replicate function. First, we will"
"0","### need to make an array to store the MSPEs"
"0","CV.MSPEs <- array(0, dim = c(M, 5))"
"0","colnames(CV.MSPEs) <- c(""temp"", ""wind"", ""solar"", ""all"", ""intcurv"") "
"0","### Set model names"
"0",""
"0","library(dplyr)"
"0","for (i in 1:M) {"
"0","  ### Use fold i for validation and the rest for training"
"0","  data.train <- filter(data.CV, fold != i)"
"0","  data.valid <- filter(data.CV, fold == i)"
"0",""
"0","  ### Remove fold from training and validation sets since it"
"0","  ### isn't a real predictor"
"0","  data.train <- select(data.train, -fold)"
"0","  data.valid <- select(data.valid, -fold)"
"0",""
"0","  ### Fit linear models to predict Ozone using each predictor"
"0","  ### individually, all predictors together, and all interactions"
"0","  ### Note: These models must be fit using data.train so that we can"
"0","  ### evaluate their MSPE on data.valid"
"0","  fit.temp <- lm(Ozone ~ Temp, data = data.train)"
"0","  fit.wind <- lm(Ozone ~ Wind, data = data.train)"
"0","  fit.solar <- lm(Ozone ~ Solar.R, data = data.train)"
"0","  fit.all <- lm(Ozone ~ Temp + Wind + Solar.R, data = data.train)"
"0","  fit.intcurv <- lm(Ozone ~ Temp + Wind + Solar.R + I(Temp^2) + I(Wind^2) + I(Solar.R^2)"
"0","  + Temp*Wind + Temp*Solar.R + Wind*Solar.R, data = data.train)"
"0",""
"0",""
"0","  ### Get predictions on the validation set for each model using the"
"0","  ### predict() function."
"0","  pred.temp <- predict(fit.temp, data.valid)"
"0","  pred.wind <- predict(fit.wind, data.valid)"
"0","  pred.solar <- predict(fit.solar, data.valid)"
"0","  pred.all <- predict(fit.all, data.valid)"
"0","  pred.intcurv <- predict(fit.intcurv, data.valid)"
"0",""
"0","  ### Use our get.MSPE() function to calculate the validation set MSPE"
"0","  ### of each model"
"0","  Y.valid <- data.valid$Ozone"
"0","  MSPE.temp <- get.MSPE(Y.valid, pred.temp)"
"0","  MSPE.wind <- get.MSPE(Y.valid, pred.wind)"
"0","  MSPE.solar <- get.MSPE(Y.valid, pred.solar)"
"0","  MSPE.all <- get.MSPE(Y.valid, pred.all)"
"0","  MSPE.intcurv <- get.MSPE(Y.valid, pred.intcurv)"
"0",""
"0","  ### Store MSPEs"
"0","  CV.MSPEs[i, 1] <- MSPE.temp"
"0","  CV.MSPEs[i, 2] <- MSPE.wind"
"0","  CV.MSPEs[i, 3] <- MSPE.solar"
"0","  CV.MSPEs[i, 4] <- MSPE.all"
"0","  CV.MSPEs[i, 5] <- MSPE.intcurv"
"0","}"
"0",""
"0","MSPE.mean <- apply(X = CV.MSPEs, MARGIN = 2 , FUN = mean)"
"0","MSPE.mean #means"
"1","    temp "
"1","    wind "
"1","   solar "
"1","     all "
"1"," intcurv "
"1","
"
"1","570.7978 "
"1","703.3529 "
"1","984.2164 "
"1","462.2584 "
"1","365.9409 "
"1","
"
"0","MSPE.sd <- apply(X = CV.MSPEs, MARGIN = 2 , FUN = sd)"
"0","MSPE.CIl <- MSPE.mean - qt (p = .975 , df = M-1) * MSPE.sd/sqrt(M)"
"0","MSPE.CIu <- MSPE.mean + qt (p = .975 , df = M-1) * MSPE.sd/sqrt(M)"
"0","round(cbind(MSPE.CIl,MSPE.CIu), 2) #confidence intervals"
"1","       "
"1"," MSPE.CIl"
"1"," MSPE.CIu"
"1","
temp   "
"1","   283.95"
"1","   857.65"
"1","
wind   "
"1","   587.57"
"1","   819.13"
"1","
solar  "
"1","   807.92"
"1","  1160.52"
"1","
all    "
"1","   263.05"
"1","   661.47"
"1","
intcurv"
"1","   229.59"
"1","   502.29"
"1","
"
