"0","library(stringr)"
"0","library(MASS)"
"0","library(glmnet)"
"0","library(pls)"
"0",""
"0","K <- 100"
"0",""
"0","### Construct folds"
"0","n <- nrow(proj) # Sample size"
"0","folds <- get.folds(n, K)"
"0",""
"0","### Create a container for MSPEs. Let's include ordinary least-squares"
"0","### regression for reference"
"0","all.models <- c(""Ridge"", ""LASSO-Min"", ""LASSO-1se"", ""LS"", ""hybrid stepwise"", ""PLS"")"
"0","all.MSPEs <- array(0, dim = c(K, length(all.models)))"
"0","colnames(all.MSPEs) <- all.models"
"0",""
"0","### Begin cross-validation"
"0","for (i in 1:K) {"
"0","  ### Split data"
"0","  data.train <- proj[folds != i, ]"
"0","  data.valid <- proj[folds == i, ]"
"0","  n.train <- nrow(data.train)"
"0",""
"0","  ### Get response vectors"
"0","  Y.train <- data.train$Y"
"0","  Y.valid <- data.valid$Y"
"0",""
"0","  ### Let's do LS. ###"
"0",""
"0","  fit.ls <- lm(Y ~ ., data = data.train)"
"0","  pred.ls <- predict(fit.ls, newdata = data.valid)"
"0","  MSPE.ls <- get.MSPE(Y.valid, pred.ls)"
"0","  all.MSPEs[i, ""LS""] <- MSPE.ls"
"0","  "
"0","  ### Let's do ridge regression.  ###"
"0",""
"0","  lambda.vals <- seq(from = 0, to = 100, by = 0.05)"
"0",""
"0","  fit.ridge <- lm.ridge(Y ~ .,"
"0","    lambda = lambda.vals,"
"0","    data = data.train"
"0","  )"
"0",""
"0","  ind.min.GCV <- which.min(fit.ridge$GCV)"
"0","  lambda.min <- lambda.vals[ind.min.GCV]"
"0",""
"0","  all.coefs.ridge <- coef(fit.ridge)"
"0","  coef.min <- all.coefs.ridge[ind.min.GCV, ]"
"0",""
"0","  matrix.valid.ridge <- model.matrix(Y ~ ., data = data.valid)"
"0",""
"0",""
"0","  pred.ridge <- matrix.valid.ridge %*% coef.min"
"0","  MSPE.ridge <- get.MSPE(Y.valid, pred.ridge)"
"0","  all.MSPEs[i, ""Ridge""] <- MSPE.ridge"
"0",""
"0","  ### Now we can do the LASSO. ###"
"0",""
"0","  matrix.train.raw <- model.matrix(Y ~ ., data = data.train)"
"0","  matrix.train <- matrix.train.raw[, -1]"
"0",""
"0","  ### 'Best' can refer to"
"0","  ### either the value of lambda which gives the smallest CV-MSPE"
"0","  ### (called the min rule), or the value of lambda which gives the"
"0","  ### simplest model that gives CV-MSPE close to the minimum (called"
"0","  ### the 1se rule). "
"0","  all.LASSOs <- cv.glmnet(x = matrix.train, y = Y.train)"
"0",""
"0","  lambda.min <- all.LASSOs$lambda.min"
"0","  lambda.1se <- all.LASSOs$lambda.1se"
"0",""
"0","  coef.LASSO.min <- predict(all.LASSOs, s = lambda.min, type = ""coef"")"
"0","  coef.LASSO.1se <- predict(all.LASSOs, s = lambda.1se, type = ""coef"")"
"0",""
"0","  included.LASSO.min <- predict(all.LASSOs,"
"0","    s = lambda.min,"
"0","    type = ""nonzero"""
"0","  )"
"0","  included.LASSO.1se <- predict(all.LASSOs,"
"0","    s = lambda.1se,"
"0","    type = ""nonzero"""
"0","  )"
"0",""
"0","  matrix.valid.LASSO.raw <- model.matrix(Y ~ ., data = data.valid)"
"0","  matrix.valid.LASSO <- matrix.valid.LASSO.raw[, -1]"
"0","  pred.LASSO.min <- predict(all.LASSOs,"
"0","    newx = matrix.valid.LASSO,"
"0","    s = lambda.min, type = ""response"""
"0","  )"
"0","  pred.LASSO.1se <- predict(all.LASSOs,"
"0","    newx = matrix.valid.LASSO,"
"0","    s = lambda.1se, type = ""response"""
"0","  )"
"0",""
"0","  MSPE.LASSO.min <- get.MSPE(Y.valid, pred.LASSO.min)"
"0","  all.MSPEs[i, ""LASSO-Min""] <- MSPE.LASSO.min"
"0",""
"0","  MSPE.LASSO.1se <- get.MSPE(Y.valid, pred.LASSO.1se)"
"0","  all.MSPEs[i, ""LASSO-1se""] <- MSPE.LASSO.1se"
"0","  "
"0","  ### the hybrid stepwise"
"0","  "
"0","  step <- step("
"0","    object = lm(Y ~ 1, data = data.train), scope = list(upper = fit.ls), direction = ""both"","
"0","    k = log(nrow(data.train)), trace = 0)"
"0","  pred.sw <- predict(step, as.data.frame(data.valid))"
"0","  MSPE.sw <- get.MSPE(Y.valid, pred.sw)"
"0","  all.MSPEs[i, ""hybrid stepwise""] <- MSPE.sw"
"0","  "
"0","  ### Partial Least Squares (PLS)"
"0","  fit_pls <- plsr(Y ~ .,"
"0","    data = data.train, validation = ""CV"")"
"0",""
"0","  CV_pls <- fit_pls$validation"
"0","  pls_comps <- CV_pls$PRESS"
"0","  n_comps <- which.min(pls_comps)"
"0",""
"0","  pred.pls <- predict(fit_pls, data.valid, ncomp = n_comps)"
"0","  MSPE.pls <- get.MSPE(Y.valid, pred.pls)"
"0","  all.MSPEs[i, ""PLS""] <- MSPE.pls"
"0","}"
"0",""
"0",""
