fit.all <- lm(Ozone ~ Temp + Wind + Solar.R, data = data.train)
fit.intcurv <- lm(Ozone ~ Temp + Wind + Solar.R + I(Temp^2) + I(Wind^2) + I(Solar.R^2)
+ Temp*Wind + Temp*Solar.R + Wind*Solar.R, data = data.train)
### Get predictions on the validation set for each model using the
### predict() function.
pred.temp <- predict(fit.temp, data.valid)
pred.wind <- predict(fit.wind, data.valid)
pred.solar <- predict(fit.solar, data.valid)
pred.all <- predict(fit.all, data.valid)
pred.intcurv <- predict(fit.intcurv, data.valid)
### Use our get.MSPE() function to calculate the validation set MSPE
### of each model
Y.valid <- data.valid$Ozone
MSPE.temp <- get.MSPE(Y.valid, pred.temp)
MSPE.wind <- get.MSPE(Y.valid, pred.wind)
MSPE.solar <- get.MSPE(Y.valid, pred.solar)
MSPE.all <- get.MSPE(Y.valid, pred.all)
MSPE.intcurv <- get.MSPE(Y.valid, pred.intcurv)
##############################################################
### This part is new!! Store calculated MSPEs in our array ###
### Note: We use the loop variable to tell which column of ###
### our array to use.                                      ###
##############################################################
all.split.MSPEs[i, 1] <- MSPE.temp
all.split.MSPEs[i, 2] <- MSPE.wind
all.split.MSPEs[i, 3] <- MSPE.solar
all.split.MSPEs[i, 4] <- MSPE.all
all.split.MSPEs[i, 5] <- MSPE.intcurv
}
### We now have validation set MSPEs for our models, let's make
### boxplots. We can give our boxplot a title using an optional input
### called "main". This is how you set titles in most plotting functions in R
boxplot(all.split.MSPEs,
main = "Boxplot of validation set MSPEs for 5 data splits"
)
View(all.split.MSPEs)
?mean
mean(all.split.MSPEs)
ind.train
data.train
Y.valid
MSPE.temp
MSPE.intcurv
pred.temp
setwd("C:/Users/Terry Liu/Desktop/STAT 452/Class Examples")
remove(list=ls())
prostate <- read.csv("Prostate.csv", header = TRUE, sep = ",",
na.strings = " ")
prostate <- read.table("Prostate.csv",
header = TRUE, sep = ",", na.strings = " "
)
mod.vol <- lm(lpsa ~ lcavol, data = prostate)
mod.pgg <- lm(lpsa ~ pgg45, data = prostate)
mod2 <- lm(lpsa ~ lcavol + pgg45, data = prostate)
n <- nrow(prostate) # store sample size for easy calculations later
# Set seed to get repeatable results.  Rerun without resetting seed to see variability
set.seed(120401002)
# Set sampling fraction.  Here I choose 70/15/15 percents
sf1 <- 0.7
sf2 <- 0.15
reorder <- sample.int(n = n, size = n, replace = FALSE)
reorder
set <- ifelse(test = (reorder < sf1 * n), yes = 1,
no = ifelse(test = (sf1 * n < reorder & reorder < (sf1 + sf2) * n), yes = 2, no = 3)
)
set
mod.vol.s1 <- lm(lpsa ~ lcavol, data = prostate[set == 1, ])
mod.pgg.s1 <- lm(lpsa ~ pgg45, data = prostate[set == 1, ])
mod2.s1 <- lm(lpsa ~ lcavol + pgg45, data = prostate[set == 1, ])
pred.v.s1 <- predict(mod.vol.s1, newdata = prostate[set == 2, ])
pred.p.s1 <- predict(mod.pgg.s1, newdata = prostate[set == 2, ])
pred.2.s1 <- predict(mod2.s1, newdata = prostate[set == 2, ])
(MSPE.v.s1 <- mean((prostate[set == 2, "lpsa"] - pred.v.s1)^2))
(MSPE.p.s1 <- mean((prostate[set == 2, "lpsa"] - pred.p.s1)^2))
(MSPE.2.s1 <- mean((prostate[set == 2, "lpsa"] - pred.2.s1)^2))
## Best model is 2-variable model, so compute test error there using all other data
mod2.s2 <- lm(lpsa ~ lcavol + pgg45, data = prostate[set < 3, ])
setwd("C:/Users/Terry Liu/Desktop/STAT 452/Tut")
### I have written the first few lines from the previous tutorial in a
### separate R file called "Read Wine.R". This file will also remove the
### outlier. We can run it using the source() function.
### First, make sure that the working directory is set correctly. Change
### the address in setwd() to wherever you have the wine dataset stored.
# setwd("C:/Users/yuxingracefan/Desktop/stats452/L3")
source("Read_Wine_Data.R")
### Set R's pseudo-random number generator to start at the same
### place every time we run this script. The actual number used
### doesn't matter.
set.seed(17648372)
### Split the data into training and test sets.
### 75%/25% seems reasonable
n <- nrow(data)
new.order <- sample.int(n) ### Shuffled numbers from 1 to n
size.train <- floor(n * 0.75) ### Number of observations in our training
### set. Use floor() to round down
ind.train <- new.order[1:size.train] ### Indices of observations
### to put in training set
ind.valid <- new.order[(size.train + 1):n] ### Indices of observations
### to put in validation set
data.train <- data[ind.train, ] ### Keep only observations in ind.train
remove(list=ls())
### I have written the first few lines from the previous tutorial in a
### separate R file called "Read Wine.R". This file will also remove the
### outlier. We can run it using the source() function.
### First, make sure that the working directory is set correctly. Change
### the address in setwd() to wherever you have the wine dataset stored.
# setwd("C:/Users/yuxingracefan/Desktop/stats452/L3")
source("Read_Wine_Data.R")
### Set R's pseudo-random number generator to start at the same
### place every time we run this script. The actual number used
### doesn't matter.
set.seed(17648372)
### Split the data into training and test sets.
### 75%/25% seems reasonable
n <- nrow(data)
new.order <- sample.int(n) ### Shuffled numbers from 1 to n
size.train <- floor(n * 0.75) ### Number of observations in our training
### set. Use floor() to round down
ind.train <- new.order[1:size.train] ### Indices of observations
### to put in training set
ind.valid <- new.order[(size.train + 1):n] ### Indices of observations
### to put in validation set
data.train <- data[ind.train, ] ### Keep only observations in ind.train
data.valid <- data[ind.valid, ] ### Keep only observations in ind.valid
### Fit linear models to predict alcohol using each predictor
### individually, all predictors together, and all interactions
### Note: These models must be fit using data.train so that we can
### evaluate their MSPE on data.valid
fit.sugar <- lm(alcohol ~ sugar, data = data.train)
fit.density <- lm(alcohol ~ density, data = data.train)
fit.pH <- lm(alcohol ~ pH, data = data.train)
fit.sulphates <- lm(alcohol ~ sulphates, data = data.train)
fit.all <- lm(alcohol ~ ., data = data.train)
fit.int <- lm(alcohol ~ .^2, data = data.train)
### Get predictions on the validation set for each model using the
### predict() function.
pred.sugar <- predict(fit.sugar, data.valid)
pred.density <- predict(fit.density, data.valid)
pred.pH <- predict(fit.pH, data.valid)
pred.sulphates <- predict(fit.sulphates, data.valid)
pred.all <- predict(fit.all, data.valid)
pred.int <- predict(fit.int, data.valid)
### When we calculate validation set MSPEs for our models, we will
### end up repeating the same calculation 5 times. Let's make a
### function to do this for us.
### I will discuss the syntax of writing functions in my video
get.MSPE <- function(Y, Y.hat) {
residuals <- Y - Y.hat
resid.sq <- residuals^2
SSPE <- sum(resid.sq)
MSPE <- SSPE / length(Y)
return(MSPE)
}
### Use our get.MSPE() function to calculate the validation set MSPE
### of each model
Y.valid <- data.valid$alcohol
MSPE.sugar <- get.MSPE(Y.valid, pred.sugar)
MSPE.density <- get.MSPE(Y.valid, pred.density)
MSPE.pH <- get.MSPE(Y.valid, pred.pH)
MSPE.sulphates <- get.MSPE(Y.valid, pred.sulphates)
MSPE.all <- get.MSPE(Y.valid, pred.all)
MSPE.int <- get.MSPE(Y.valid, pred.int)
### Set R's pseudo-random number generator to start at the same
### place every time we run this script. The actual number used
### doesn't matter.
set.seed(17648372)
remove(list=ls())
AQ <- na.omit(airquality[,1:4])
dim(AQ)
head(AQ)
pairs(AQ)
set.seed(4099183)
n = nrow(AQ)
reorder = sample.int(n)
size.train <- floor(n * 0.75) ### Number of observations in our training
### set. Use floor() to round down
ind.train <- reorder[1:size.train] ### Indices of observations
### to put in training set
ind.valid <- reorder[(size.train + 1):n] ### Indices of observations
### to put in validation set
data.train <- AQ[ind.train,] ### Keep only observations in ind.train
data.valid <- AQ[ind.valid,] ### Keep only observations in ind.valid
print(ind.valid)
### Fit linear models to predict Ozone using each predictor
### individually, all predictors together, and all interactions with curvature
### Note: These models must be fit using data.train so that we can
### evaluate their MSPE on data.valid
fit.temp <- lm(Ozone ~ Temp, data = data.train)
fit.wind <- lm(Ozone ~ Wind, data = data.train)
fit.solar <- lm(Ozone ~ Solar.R, data = data.train)
fit.all <- lm(Ozone ~ Temp + Wind + Solar.R, data = data.train)
fit.intcurv <- lm(Ozone ~ Temp + Wind + Solar.R + I(Temp^2) + I(Wind^2) + I(Solar.R^2)
+ Temp*Wind + Temp*Solar.R + Wind*Solar.R, data = data.train)
### Get predictions on the validation set for each model using the
### predict() function.
pred.temp <- predict(fit.temp, data.valid)
pred.wind <- predict(fit.wind, data.valid)
pred.solar <- predict(fit.solar, data.valid)
pred.all <- predict(fit.all, data.valid)
pred.intcurv <- predict(fit.intcurv, data.valid)
### When we calculate validation set MSPEs for our models, we will
### end up repeating the same calculation 5 times. Let's make a
### function to do this for us.
get.MSPE <- function(Y, Y.hat) {
residuals <- Y - Y.hat
resid.sq <- residuals^2
SSPE <- sum(resid.sq)
MSPE <- SSPE / length(Y)
return(MSPE)
}
### Use our get.MSPE() function to calculate the validation set MSPE
### of each model
Y.valid <- data.valid$Ozone
MSPE.temp <- get.MSPE(Y.valid, pred.temp)
MSPE.wind <- get.MSPE(Y.valid, pred.wind)
MSPE.solar <- get.MSPE(Y.valid, pred.solar)
MSPE.all <- get.MSPE(Y.valid, pred.all)
MSPE.intcurv <- get.MSPE(Y.valid, pred.intcurv)
### Let's compare these validation set MSPEs
print(MSPE.temp)
print(MSPE.wind)
print(MSPE.solar)
print(MSPE.all)
print(MSPE.intcurv)
summary(fit.temp)
data.train
?plot
plot(Temp, Ozone, data=data.train)
plot(data.train$Temp, data.train$Ozone)
plot(data.train$Wind, data.train$Ozone)
plot(data.train$Solar.R, data.train$Ozone)
data.valid$Ozone
data.train
pred.temp
fit.temp
dim(pred.temp)
pred.temp
length(pred.temp)
length(data.valid)
dim(data.valid)
data.valid
reorder
length(reorder)
dim(AQ)
length(size.train)
size.train
length(ind.train)
len(ind.train)
length(ind.train)
length(ind.valid)
length(data.train)
dim(data.train)
dim(data.valid)
### Fit linear models to predict Ozone using each predictor
### individually, all predictors together, and all interactions with curvature
### Note: These models must be fit using data.train so that we can
### evaluate their MSPE on data.valid
fit.temp <- lm(Ozone ~ Temp, data = data.train)
fit.wind <- lm(Ozone ~ Wind, data = data.train)
fit.solar <- lm(Ozone ~ Solar.R, data = data.train)
fit.all <- lm(Ozone ~ Temp + Wind + Solar.R, data = data.train)
fit.intcurv <- lm(Ozone ~ Temp + Wind + Solar.R + I(Temp^2) + I(Wind^2) + I(Solar.R^2)
+ Temp*Wind + Temp*Solar.R + Wind*Solar.R, data = data.train)
### Get predictions on the validation set for each model using the
### predict() function.
pred.temp <- predict(fit.temp, data.valid)
pred.wind <- predict(fit.wind, data.valid)
pred.solar <- predict(fit.solar, data.valid)
pred.all <- predict(fit.all, data.valid)
pred.intcurv <- predict(fit.intcurv, data.valid)
### When we calculate validation set MSPEs for our models, we will
### end up repeating the same calculation 5 times. Let's make a
### function to do this for us.
get.MSPE <- function(Y, Y.hat) {
residuals <- Y - Y.hat
resid.sq <- residuals^2
SSPE <- sum(resid.sq)
MSPE <- SSPE / length(Y)
return(MSPE)
}
### Use our get.MSPE() function to calculate the validation set MSPE
### of each model
Y.valid <- data.valid$Ozone
MSPE.temp <- get.MSPE(Y.valid, pred.temp)
MSPE.wind <- get.MSPE(Y.valid, pred.wind)
MSPE.solar <- get.MSPE(Y.valid, pred.solar)
MSPE.all <- get.MSPE(Y.valid, pred.all)
MSPE.intcurv <- get.MSPE(Y.valid, pred.intcurv)
### Let's compare these validation set MSPEs
print(MSPE.temp)
print(MSPE.wind)
print(MSPE.solar)
print(MSPE.all)
print(MSPE.intcurv)
knitr::opts_chunk$set(echo = TRUE)
AQ <- na.omit(airquality[,1:4])
dim(AQ)
head(AQ)
pairs(AQ)
set.seed(4099183)
n = nrow(AQ)
reorder = sample.int(n)
size.train <- floor(n * 0.75) ### Number of observations in our training
### set. Use floor() to round down
ind.train <- reorder[1:size.train] ### Indices of observations
### to put in training set
ind.valid <- reorder[(size.train + 1):n] ### Indices of observations
### to put in validation set
data.train <- AQ[ind.train,] ### Keep only observations in ind.train
data.valid <- AQ[ind.valid,] ### Keep only observations in ind.valid
print(ind.valid)
### Fit linear models to predict Ozone using each predictor
### individually, all predictors together, and all interactions with curvature
### Note: These models must be fit using data.train so that we can
### evaluate their MSPE on data.valid
fit.temp <- lm(Ozone ~ Temp, data = data.train)
fit.wind <- lm(Ozone ~ Wind, data = data.train)
fit.solar <- lm(Ozone ~ Solar.R, data = data.train)
fit.all <- lm(Ozone ~ Temp + Wind + Solar.R, data = data.train)
fit.intcurv <- lm(Ozone ~ Temp + Wind + Solar.R + I(Temp^2) + I(Wind^2) + I(Solar.R^2)
+ Temp*Wind + Temp*Solar.R + Wind*Solar.R, data = data.train)
### Get predictions on the validation set for each model using the
### predict() function.
pred.temp <- predict(fit.temp, data.valid)
pred.wind <- predict(fit.wind, data.valid)
pred.solar <- predict(fit.solar, data.valid)
pred.all <- predict(fit.all, data.valid)
pred.intcurv <- predict(fit.intcurv, data.valid)
### When we calculate validation set MSPEs for our models, we will
### end up repeating the same calculation 5 times. Let's make a
### function to do this for us.
get.MSPE <- function(Y, Y.hat) {
residuals <- Y - Y.hat
resid.sq <- residuals^2
SSPE <- sum(resid.sq)
MSPE <- SSPE / length(Y)
return(MSPE)
}
### Use our get.MSPE() function to calculate the validation set MSPE
### of each model
Y.valid <- data.valid$Ozone
MSPE.temp <- get.MSPE(Y.valid, pred.temp)
MSPE.wind <- get.MSPE(Y.valid, pred.wind)
MSPE.solar <- get.MSPE(Y.valid, pred.solar)
MSPE.all <- get.MSPE(Y.valid, pred.all)
MSPE.intcurv <- get.MSPE(Y.valid, pred.intcurv)
### Let's compare these validation set MSPEs
print(MSPE.temp)
print(MSPE.wind)
print(MSPE.solar)
print(MSPE.all)
print(MSPE.intcurv)
M <- 5 ### number of times to split
all.split.MSPEs <- array(0, c(M, 5)) ### An array to store calculated
### MSPEs.
colnames(all.split.MSPEs) <- c("temp", "wind", "solar", "all", "intcurv") ### Set model names
for (i in 1:M) {
#######################################################################
### Most of this code is copy-pasted from above. A few things that  ###
### would be redundant have been deleted.                           ###
#######################################################################
reorder = sample.int(n)
size.train <- floor(n * 0.75) ### Number of observations in our training
### set. Use floor() to round down
ind.train <- reorder[1:size.train] ### Indices of observations
### to put in training set
ind.valid <- reorder[(size.train + 1):n] ### Indices of observations
### to put in validation set
data.train <- AQ[ind.train,] ### Keep only observations in ind.train
data.valid <- AQ[ind.valid,] ### Keep only observations in ind.valid
### Fit linear models to predict Ozone using each predictor
### individually, all predictors together, and all interactions with curvature
### Note: These models must be fit using data.train so that we can
### evaluate their MSPE on data.valid
fit.temp <- lm(Ozone ~ Temp, data = data.train)
fit.wind <- lm(Ozone ~ Wind, data = data.train)
fit.solar <- lm(Ozone ~ Solar.R, data = data.train)
fit.all <- lm(Ozone ~ Temp + Wind + Solar.R, data = data.train)
fit.intcurv <- lm(Ozone ~ Temp + Wind + Solar.R + I(Temp^2) + I(Wind^2) + I(Solar.R^2)
+ Temp*Wind + Temp*Solar.R + Wind*Solar.R, data = data.train)
### Get predictions on the validation set for each model using the
### predict() function.
pred.temp <- predict(fit.temp, data.valid)
pred.wind <- predict(fit.wind, data.valid)
pred.solar <- predict(fit.solar, data.valid)
pred.all <- predict(fit.all, data.valid)
pred.intcurv <- predict(fit.intcurv, data.valid)
### Use our get.MSPE() function to calculate the validation set MSPE
### of each model
Y.valid <- data.valid$Ozone
MSPE.temp <- get.MSPE(Y.valid, pred.temp)
MSPE.wind <- get.MSPE(Y.valid, pred.wind)
MSPE.solar <- get.MSPE(Y.valid, pred.solar)
MSPE.all <- get.MSPE(Y.valid, pred.all)
MSPE.intcurv <- get.MSPE(Y.valid, pred.intcurv)
##############################################################
### This part is new!! Store calculated MSPEs in our array ###
### Note: We use the loop variable to tell which column of ###
### our array to use.                                      ###
##############################################################
all.split.MSPEs[i, 1] <- MSPE.temp
all.split.MSPEs[i, 2] <- MSPE.wind
all.split.MSPEs[i, 3] <- MSPE.solar
all.split.MSPEs[i, 4] <- MSPE.all
all.split.MSPEs[i, 5] <- MSPE.intcurv
}
View(all.split.MSPEs)
all.split.MSPEs$temp
all.split.MSPEs[,1]
MSPEs.mean = array(0,5)
colnames(MSPEs.mean) <- colnames(all.split.MSPEs)
MSPEs.mean = array(0,c(1,5))
colnames(MSPEs.mean) <- colnames(all.split.MSPEs)
mean(all.split.MSPEs[,1])
MSPEs.mean = array(0,c(1,M)) # make empty array to be filled in with means
colnames(MSPEs.mean) <- colnames(all.split.MSPEs) # copy the column names
for (i in 1:M){
MSPEs.mean[i] = mean(all.split.MSPEs[,i]) #fill in the means
}
MSPEs.mean
MSPEs.CI = array(0, c(2, M))
View(MSPEs.CI)
# make empty matrix to be filled in with confidence intervals
# row 1 will be lower bound, and row 2 is upper
colnames(MSPEs.mean) <- colnames(all.split.MSPEs)
# make empty matrix to be filled in with confidence intervals
# row 1 will be lower bound, and row 2 is upper
colnames(MSPEs.CI) <- colnames(all.split.MSPEs)
rownames(MSPEs.CI) <- c("lower", "upper")
?apply(array, margin, ...)
MSPE.mean <- apply (X = all.split.MSPEs, MARGIN = 2 , FUN = mean)
MSPE.mean
MSPE.mean <- apply(X = all.split.MSPEs, MARGIN = 2 , FUN = mean)
MSPE.mean
MSPE.sd <- apply(X = all.split.MSPEs, MARGIN = 2 , FUN = sd)
MSPE.CIl <- MSPE.mean - qt (p = .975 , df = M-1) * MSPE.sd/sqrt(M)
MSPE.CIu <- MSPE.mean + qt (p = .975 , df = M-1) * MSPE.sd/sqrt(M)
round(cbind(MSPE.CIl,MSPE.CIu), 2)
### We need to divide the dataset into 20 folds.
### We can do this by randomly sampling the numbers from 1 to 10 and
### attaching these to our dataset as fold labels
n.fold <- n / 20 # Number of observations in each fold
n.fold <- ceiling(n.fold) # Round up to make sure we get enough labels
# We can remove any excess later
ordered.ids <- rep(1:20, times = n.fold)
ordered.ids <- ordered.ids[1:n] # Remove excess label(s)
shuffle <- sample.int(n) # Randomly permute the numbers 1 to n
shuffled.ids <- ordered.ids[shuffle] # Use shuffle to permute
# the fold labels
data.CV <- AQ # Create a copy of our dataset
data.CV$fold <- shuffled.ids # Add a column to our new dataset containing
# the fold labels
### Next, let's actually do the cross validation. This will be easier
### with a for loop than with the replicate function. First, we will
### need to make an array to store the MSPEs
CV.MSPEs <- array(0, dim = c(20, M))
colnames(CV.MSPEs) <- colnames(all.split.MSPEs) # We can recycle the
# model names from
# all.split.MSPEs
for (i in 1:20) {
### Use fold i for validation and the rest for training
data.train <- filter(data.CV, fold != i)
data.valid <- filter(data.CV, fold == i)
### Remove fold from training and validation sets since it
### isn't a real predictor
data.train <- select(data.train, -fold)
data.valid <- select(data.valid, -fold)
### Fit linear models to predict Ozone using each predictor
### individually, all predictors together, and all interactions
### Note: These models must be fit using data.train so that we can
### evaluate their MSPE on data.valid
fit.temp <- lm(Ozone ~ Temp, data = data.train)
fit.wind <- lm(Ozone ~ Wind, data = data.train)
fit.solar <- lm(Ozone ~ Solar.R, data = data.train)
fit.all <- lm(Ozone ~ Temp + Wind + Solar.R, data = data.train)
fit.intcurv <- lm(Ozone ~ Temp + Wind + Solar.R + I(Temp^2) + I(Wind^2) + I(Solar.R^2)
+ Temp*Wind + Temp*Solar.R + Wind*Solar.R, data = data.train)
### Get predictions on the validation set for each model using the
### predict() function.
pred.temp <- predict(fit.temp, data.valid)
pred.wind <- predict(fit.wind, data.valid)
pred.solar <- predict(fit.solar, data.valid)
pred.all <- predict(fit.all, data.valid)
pred.intcurv <- predict(fit.intcurv, data.valid)
### Use our get.MSPE() function to calculate the validation set MSPE
### of each model
Y.valid <- data.valid$Ozone
MSPE.temp <- get.MSPE(Y.valid, pred.temp)
MSPE.wind <- get.MSPE(Y.valid, pred.wind)
MSPE.solar <- get.MSPE(Y.valid, pred.solar)
MSPE.all <- get.MSPE(Y.valid, pred.all)
MSPE.intcurv <- get.MSPE(Y.valid, pred.intcurv)
### Store MSPEs
CV.MSPEs[i, 1] <- MSPE.temp
CV.MSPEs[i, 2] <- MSPE.wind
CV.MSPEs[i, 3] <- MSPE.solar
CV.MSPEs[i, 4] <- MSPE.all
CV.MSPEs[i, 5] <- MSPE.intcurv
}
### Make a boxplot of the scores
boxplot(CV.MSPEs,
main = "Boxplot of CV Error With 20 Folds"
)
### Calculate relative errors and make boxplots
rel.CV.MSPEs <- apply(CV.MSPEs, 1, function(W) {
best <- min(W)
return(W / best)
})
rel.CV.MSPEs <- t(rel.CV.MSPEs)
boxplot(rel.CV.MSPEs,
main = "Boxplot of Relative CV Error With 10 Folds"
)
