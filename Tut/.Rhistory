### isn't a real predictor
data.train <- select(data.train, -fold)
data.valid <- select(data.valid, -fold)
### Fit linear models to predict Ozone using each predictor
### individually, all predictors together, and all interactions
### Note: These models must be fit using data.train so that we can
### evaluate their MSPE on data.valid
fit.temp <- lm(Ozone ~ Temp, data = data.train)
fit.wind <- lm(Ozone ~ Wind, data = data.train)
fit.solar <- lm(Ozone ~ Solar.R, data = data.train)
fit.all <- lm(Ozone ~ Temp + Wind + Solar.R, data = data.train)
fit.intcurv <- lm(Ozone ~ Temp + Wind + Solar.R + I(Temp^2) + I(Wind^2) + I(Solar.R^2)
+ Temp*Wind + Temp*Solar.R + Wind*Solar.R, data = data.train)
### Get predictions on the validation set for each model using the
### predict() function.
pred.temp <- predict(fit.temp, data.valid)
pred.wind <- predict(fit.wind, data.valid)
pred.solar <- predict(fit.solar, data.valid)
pred.all <- predict(fit.all, data.valid)
pred.intcurv <- predict(fit.intcurv, data.valid)
### Use our get.MSPE() function to calculate the validation set MSPE
### of each model
Y.valid <- data.valid$Ozone
MSPE.temp <- get.MSPE(Y.valid, pred.temp)
MSPE.wind <- get.MSPE(Y.valid, pred.wind)
MSPE.solar <- get.MSPE(Y.valid, pred.solar)
MSPE.all <- get.MSPE(Y.valid, pred.all)
MSPE.intcurv <- get.MSPE(Y.valid, pred.intcurv)
### Store MSPEs
CV.MSPEs[i, 1] <- MSPE.temp
CV.MSPEs[i, 2] <- MSPE.wind
CV.MSPEs[i, 3] <- MSPE.solar
CV.MSPEs[i, 4] <- MSPE.all
CV.MSPEs[i, 5] <- MSPE.intcurv
}
MSPE.mean <- apply(X = CV.MSPEs, MARGIN = 2 , FUN = mean)
MSPE.mean #means
MSPE.sd <- apply(X = CV.MSPEs, MARGIN = 2 , FUN = sd)
MSPE.CIl <- MSPE.mean - qt (p = .975 , df = M-1) * MSPE.sd/sqrt(M)
MSPE.CIu <- MSPE.mean + qt (p = .975 , df = M-1) * MSPE.sd/sqrt(M)
round(cbind(MSPE.CIl,MSPE.CIu), 2) #confidence intervals
n.rep <- 20 # Number of times to repeat CV
### First, we need a container to store the average CV errors
ave.CV.MSPEs <- array(0, dim = c(n.rep, 5))
colnames(ave.CV.MSPEs) <- colnames(CV.MSPEs)
### We will put the entire CV section from above inside another
### for loop. This will repeat the entire CV process
### Note: we need to use a different loop variable for the outer
### for loop. It's common to use j when you have already used i
for (j in 1:n.rep) {
ordered.ids <- rep(1:M, times = n.fold)
ordered.ids <- ordered.ids[1:n]
shuffle <- sample.int(n)
shuffled.ids <- ordered.ids[shuffle]
data.CV <- data
data.CV$fold <- shuffled.ids
CV.MSPEs <- array(0, dim = c(M, 5))
colnames(CV.MSPEs) <- colnames(all.split.MSPEs)
for (i in 1:M) {
data.train <- filter(data.CV, fold != i)
data.valid <- filter(data.CV, fold == i)
### In tutorial, I was getting an error because I wrote -folds
### instead of -fold. Whoops!
data.train <- select(data.train, -fold)
data.valid <- select(data.valid, -fold)
fit.sugar <- lm(alcohol ~ sugar, data = data.train)
fit.density <- lm(alcohol ~ density, data = data.train)
fit.pH <- lm(alcohol ~ pH, data = data.train)
fit.sulphates <- lm(alcohol ~ sulphates, data = data.train)
fit.all <- lm(alcohol ~ ., data = data.train)
fit.int <- lm(alcohol ~ .^2, data = data.train)
pred.sugar <- predict(fit.sugar, data.valid)
pred.density <- predict(fit.density, data.valid)
pred.pH <- predict(fit.pH, data.valid)
pred.sulphates <- predict(fit.sulphates, data.valid)
pred.all <- predict(fit.all, data.valid)
pred.int <- predict(fit.int, data.valid)
Y.valid <- data.valid$alcohol
MSPE.sugar <- get.MSPE(Y.valid, pred.sugar)
MSPE.density <- get.MSPE(Y.valid, pred.density)
MSPE.pH <- get.MSPE(Y.valid, pred.pH)
MSPE.sulphates <- get.MSPE(Y.valid, pred.sulphates)
MSPE.all <- get.MSPE(Y.valid, pred.all)
MSPE.int <- get.MSPE(Y.valid, pred.int)
CV.MSPEs[i, 1] <- MSPE.sugar
CV.MSPEs[i, 2] <- MSPE.density
CV.MSPEs[i, 3] <- MSPE.pH
CV.MSPEs[i, 4] <- MSPE.sulphates
CV.MSPEs[i, 5] <- MSPE.all
CV.MSPEs[i, 6] <- MSPE.int
}
### We now have MSPEs for each fold of one iteration of CV. Let's
### get the average error across these folds (think of each fold
### as a data split), and store the result in ave.CV.MSPEs
this.ave.MSPEs <- apply(CV.MSPEs, 2, mean)
ave.CV.MSPEs[j, ] <- this.ave.MSPEs # We are replacing a whole
# row at once
}
n.rep <- 20 # Number of times to repeat CV
### First, we need a container to store the average CV errors
ave.CV.MSPEs <- array(0, dim = c(n.rep, 5))
colnames(ave.CV.MSPEs) <- colnames(CV.MSPEs)
### We will put the entire CV section from above inside another
### for loop. This will repeat the entire CV process
for (j in 1:n.rep) {
ordered.ids <- rep(1:M, times = n.fold)
ordered.ids <- ordered.ids[1:n]
shuffle <- sample.int(n)
shuffled.ids <- ordered.ids[shuffle]
data.CV <- data
data.CV$fold <- shuffled.ids
CV.MSPEs <- array(0, dim = c(M, 5))
colnames(CV.MSPEs) <- colnames(all.split.MSPEs)
for (i in 1:M) {
data.train <- filter(data.CV, fold != i)
data.valid <- filter(data.CV, fold == i)
### In tutorial, I was getting an error because I wrote -folds
### instead of -fold. Whoops!
data.train <- select(data.train, -fold)
data.valid <- select(data.valid, -fold)
fit.sugar <- lm(alcohol ~ sugar, data = data.train)
fit.density <- lm(alcohol ~ density, data = data.train)
fit.pH <- lm(alcohol ~ pH, data = data.train)
fit.sulphates <- lm(alcohol ~ sulphates, data = data.train)
fit.all <- lm(alcohol ~ ., data = data.train)
fit.int <- lm(alcohol ~ .^2, data = data.train)
pred.sugar <- predict(fit.sugar, data.valid)
pred.density <- predict(fit.density, data.valid)
pred.pH <- predict(fit.pH, data.valid)
pred.sulphates <- predict(fit.sulphates, data.valid)
pred.all <- predict(fit.all, data.valid)
pred.int <- predict(fit.int, data.valid)
Y.valid <- data.valid$alcohol
MSPE.sugar <- get.MSPE(Y.valid, pred.sugar)
MSPE.density <- get.MSPE(Y.valid, pred.density)
MSPE.pH <- get.MSPE(Y.valid, pred.pH)
MSPE.sulphates <- get.MSPE(Y.valid, pred.sulphates)
MSPE.all <- get.MSPE(Y.valid, pred.all)
MSPE.int <- get.MSPE(Y.valid, pred.int)
CV.MSPEs[i, 1] <- MSPE.sugar
CV.MSPEs[i, 2] <- MSPE.density
CV.MSPEs[i, 3] <- MSPE.pH
CV.MSPEs[i, 4] <- MSPE.sulphates
CV.MSPEs[i, 5] <- MSPE.all
CV.MSPEs[i, 6] <- MSPE.int
}
### We now have MSPEs for each fold of one iteration of CV. Let's
### get the average error across these folds (think of each fold
### as a data split), and store the result in ave.CV.MSPEs
this.ave.MSPEs <- apply(CV.MSPEs, 2, mean)
ave.CV.MSPEs[j, ] <- this.ave.MSPEs # We are replacing a whole
# row at once
}
data.CV$fold
data.CV
n.rep <- 20 # Number of times to repeat CV
### First, we need a container to store the average CV errors
ave.CV.MSPEs <- array(0, dim = c(n.rep, 5))
colnames(ave.CV.MSPEs) <- colnames(CV.MSPEs)
### We will put the entire CV section from above inside another
### for loop. This will repeat the entire CV process
for (j in 1:n.rep) {
ordered.ids <- rep(1:M, times = n.fold)
ordered.ids <- ordered.ids[1:n]
shuffle <- sample.int(n)
shuffled.ids <- ordered.ids[shuffle]
data.CV <- AQ
data.CV$fold <- shuffled.ids
CV.MSPEs <- array(0, dim = c(M, 5))
colnames(CV.MSPEs) <- colnames(all.split.MSPEs)
for (i in 1:M) {
data.train <- filter(data.CV, fold != i)
data.valid <- filter(data.CV, fold == i)
### In tutorial, I was getting an error because I wrote -folds
### instead of -fold. Whoops!
data.train <- select(data.train, -fold)
data.valid <- select(data.valid, -fold)
fit.sugar <- lm(alcohol ~ sugar, data = data.train)
fit.density <- lm(alcohol ~ density, data = data.train)
fit.pH <- lm(alcohol ~ pH, data = data.train)
fit.sulphates <- lm(alcohol ~ sulphates, data = data.train)
fit.all <- lm(alcohol ~ ., data = data.train)
fit.int <- lm(alcohol ~ .^2, data = data.train)
pred.sugar <- predict(fit.sugar, data.valid)
pred.density <- predict(fit.density, data.valid)
pred.pH <- predict(fit.pH, data.valid)
pred.sulphates <- predict(fit.sulphates, data.valid)
pred.all <- predict(fit.all, data.valid)
pred.int <- predict(fit.int, data.valid)
Y.valid <- data.valid$alcohol
MSPE.sugar <- get.MSPE(Y.valid, pred.sugar)
MSPE.density <- get.MSPE(Y.valid, pred.density)
MSPE.pH <- get.MSPE(Y.valid, pred.pH)
MSPE.sulphates <- get.MSPE(Y.valid, pred.sulphates)
MSPE.all <- get.MSPE(Y.valid, pred.all)
MSPE.int <- get.MSPE(Y.valid, pred.int)
CV.MSPEs[i, 1] <- MSPE.sugar
CV.MSPEs[i, 2] <- MSPE.density
CV.MSPEs[i, 3] <- MSPE.pH
CV.MSPEs[i, 4] <- MSPE.sulphates
CV.MSPEs[i, 5] <- MSPE.all
CV.MSPEs[i, 6] <- MSPE.int
}
### We now have MSPEs for each fold of one iteration of CV. Let's
### get the average error across these folds (think of each fold
### as a data split), and store the result in ave.CV.MSPEs
this.ave.MSPEs <- apply(CV.MSPEs, 2, mean)
ave.CV.MSPEs[j, ] <- this.ave.MSPEs # We are replacing a whole
# row at once
}
n.rep <- 20 # Number of times to repeat CV
### First, we need a container to store the average CV errors
ave.CV.MSPEs <- array(0, dim = c(n.rep, 5))
colnames(ave.CV.MSPEs) <- colnames(CV.MSPEs)
### We will put the entire CV section from above inside another
### for loop. This will repeat the entire CV process
for (j in 1:n.rep) {
ordered.ids <- rep(1:M, times = n.fold)
ordered.ids <- ordered.ids[1:n]
shuffle <- sample.int(n)
shuffled.ids <- ordered.ids[shuffle]
data.CV <- AQ
data.CV$fold <- shuffled.ids
CV.MSPEs <- array(0, dim = c(M, 5))
colnames(CV.MSPEs) <- c("temp", "wind", "solar", "all", "intcurv")
for (i in 1:M) {
data.train <- filter(data.CV, fold != i)
data.valid <- filter(data.CV, fold == i)
### In tutorial, I was getting an error because I wrote -folds
### instead of -fold. Whoops!
data.train <- select(data.train, -fold)
data.valid <- select(data.valid, -fold)
fit.sugar <- lm(alcohol ~ sugar, data = data.train)
fit.density <- lm(alcohol ~ density, data = data.train)
fit.pH <- lm(alcohol ~ pH, data = data.train)
fit.sulphates <- lm(alcohol ~ sulphates, data = data.train)
fit.all <- lm(alcohol ~ ., data = data.train)
fit.int <- lm(alcohol ~ .^2, data = data.train)
pred.sugar <- predict(fit.sugar, data.valid)
pred.density <- predict(fit.density, data.valid)
pred.pH <- predict(fit.pH, data.valid)
pred.sulphates <- predict(fit.sulphates, data.valid)
pred.all <- predict(fit.all, data.valid)
pred.int <- predict(fit.int, data.valid)
Y.valid <- data.valid$alcohol
MSPE.sugar <- get.MSPE(Y.valid, pred.sugar)
MSPE.density <- get.MSPE(Y.valid, pred.density)
MSPE.pH <- get.MSPE(Y.valid, pred.pH)
MSPE.sulphates <- get.MSPE(Y.valid, pred.sulphates)
MSPE.all <- get.MSPE(Y.valid, pred.all)
MSPE.int <- get.MSPE(Y.valid, pred.int)
CV.MSPEs[i, 1] <- MSPE.sugar
CV.MSPEs[i, 2] <- MSPE.density
CV.MSPEs[i, 3] <- MSPE.pH
CV.MSPEs[i, 4] <- MSPE.sulphates
CV.MSPEs[i, 5] <- MSPE.all
CV.MSPEs[i, 6] <- MSPE.int
}
### We now have MSPEs for each fold of one iteration of CV. Let's
### get the average error across these folds (think of each fold
### as a data split), and store the result in ave.CV.MSPEs
this.ave.MSPEs <- apply(CV.MSPEs, 2, mean)
ave.CV.MSPEs[j, ] <- this.ave.MSPEs # We are replacing a whole
# row at once
}
n.rep <- 20 # Number of times to repeat CV
### First, we need a container to store the average CV errors
ave.CV.MSPEs <- array(0, dim = c(n.rep, 5))
colnames(ave.CV.MSPEs) <- colnames(CV.MSPEs)
### We will put the entire CV section from above inside another
### for loop. This will repeat the entire CV process
for (j in 1:n.rep) {
ordered.ids <- rep(1:M, times = n.fold)
ordered.ids <- ordered.ids[1:n]
shuffle <- sample.int(n)
shuffled.ids <- ordered.ids[shuffle]
data.CV <- AQ
data.CV$fold <- shuffled.ids
CV.MSPEs <- array(0, dim = c(M, 5))
colnames(CV.MSPEs) <- c("temp", "wind", "solar", "all", "intcurv")
for (i in 1:M) {
data.train <- filter(data.CV, fold != i)
data.valid <- filter(data.CV, fold == i)
### In tutorial, I was getting an error because I wrote -folds
### instead of -fold. Whoops!
data.train <- select(data.train, -fold)
data.valid <- select(data.valid, -fold)
fit.temp <- lm(Ozone ~ Temp, data = data.train)
fit.wind <- lm(Ozone ~ Wind, data = data.train)
fit.solar <- lm(Ozone ~ Solar.R, data = data.train)
fit.all <- lm(Ozone ~ Temp + Wind + Solar.R, data = data.train)
fit.intcurv <- lm(Ozone ~ Temp + Wind + Solar.R + I(Temp^2) + I(Wind^2) + I(Solar.R^2)
+ Temp*Wind + Temp*Solar.R + Wind*Solar.R, data = data.train)
pred.temp <- predict(fit.temp, data.valid)
pred.wind <- predict(fit.wind, data.valid)
pred.solar <- predict(fit.solar, data.valid)
pred.all <- predict(fit.all, data.valid)
pred.intcurv <- predict(fit.intcurv, data.valid)
Y.valid <- data.valid$Ozone
MSPE.temp <- get.MSPE(Y.valid, pred.temp)
MSPE.wind <- get.MSPE(Y.valid, pred.wind)
MSPE.solar <- get.MSPE(Y.valid, pred.solar)
MSPE.all <- get.MSPE(Y.valid, pred.all)
MSPE.intcurv <- get.MSPE(Y.valid, pred.intcurv)
CV.MSPEs[i, 1] <- MSPE.temp
CV.MSPEs[i, 2] <- MSPE.wind
CV.MSPEs[i, 3] <- MSPE.solar
CV.MSPEs[i, 4] <- MSPE.all
CV.MSPEs[i, 5] <- MSPE.intcurv
}
### We now have MSPEs for each fold of one iteration of CV. Let's
### get the average error across these folds (think of each fold
### as a data split), and store the result in ave.CV.MSPEs
this.ave.MSPEs <- apply(CV.MSPEs, 2, mean)
ave.CV.MSPEs[j, ] <- this.ave.MSPEs # We are replacing a whole
# row at once
}
boxplot(ave.CV.MSPEs,
main = "Boxplot of 20 Replicates of Average 5-Fold CV Error"
)
rel.ave.CV.MSPEs <- apply(ave.CV.MSPEs, 1, function(W) {
best <- min(W)
return(W / best)
})
rel.ave.CV.MSPEs <- t(rel.ave.CV.MSPEs)
boxplot(rel.ave.CV.MSPEs,
main = "Boxplot of 20 Replicates of Relative Average 5-Fold CV Error"
)
boxplot(ave.CV.MSPEs,
main = "Boxplot of 20 Replicates of Average 5-Fold CV Error"
)
rel.ave.CV.MSPEs <- apply(ave.CV.MSPEs, 1, function(W) {
best <- min(W)
return(W / best)
})
rel.ave.CV.MSPEs <- t(rel.ave.CV.MSPEs)
boxplot(rel.ave.CV.MSPEs,
main = "Boxplot of 20 Replicates of Relative Average 5-Fold CV Error"
)
boxplot(rel.ave.CV.MSPEs,
main = "Boxplot of 20 Replicates of Relative Average 5-Fold CV Error"
)
View(rel.ave.CV.MSPEs)
install.packages("faraway")
library(faraway)
Insurance
insurance = read.csv("Insurance.csv")
insurance = read.csv("Insurance.csv")
head(insurance)
remove(insurance)
ins = read.csv("Insurance.csv")
head(ins)
?read.csv
ins = read.csv("Insurance.csv", header = TRUE)
ins$zone <- as.factor(ins$zone)
ins$make <- as.factor(ins$make)
head(ins)
pairs(ins)
ins = read.csv("Insurance.csv", header = TRUE)
ins$zone <- as.factor(ins$zone)
ins$make <- as.factor(ins$make)
dim(ins)
head(ins)
pairs(ins)
boxplot(ins)
head(ins)
ins = read.csv("Insurance.csv", header = TRUE)
ins$zone <- as.factor(ins$zone)
ins$make <- as.factor(ins$make)
ins <- ins[ins$claims>0,]
dim(ins)
head(ins)
pairs(ins)
ins.fit = lm(per ~ ., data = ins)
summary(ins.fit)
ins.fit = lm(per ~ all, data = ins)
?lm
ins.fit = lm(per ~ . , data = ins)
summary(ins.fit)
levels(ins$zone)
levels(ins$make)
ins = read.csv("Insurance.csv", header = TRUE)
ins$zone <- as.factor(ins$zone)
ins$make <- as.factor(ins$make)
levels(ins$zone)
levels(ins$make)
ins <- ins[ins$claims>0,]
dim(ins)
head(ins)
pairs(ins)
levels(ins$zone)
# Here is how to see the information in the variable X1
class(dat$X1)
# Creating some data, saving to data frame, "dat"
set.seed(3894270)
X1 <- factor(rep(x = c("A", "B", "C", "D"), each = 5))
X2 <- round(rnorm(20), 2)
mean.y <- rep(c(3, 1, 5, 1), each = 5)
epsilon <- rnorm(20)
y <- round(mean.y + epsilon, 2)
dat <- data.frame(y, X1, X2)
# putting the columns of data side by side to make it easier to view
cbind(dat[1:5, ], dat[6:10, ], dat[11:15, ], dat[16:20, ])
# Here is how to see the information in the variable X1
class(dat$X1)
levels(dat$X1)
?levels
levels(ins$zone) <- c("B", "C", "D", "E", "F", "G", "A")
levels(ins$make) <- c("B", "C", "D", "E", "F", "G", "H", "I", "A")
levels(ins$zone) <- c("B", "C", "D", "E", "F", "G", "A")
levels(ins$make) <- c("B", "C", "D", "E", "F", "G", "H", "I", "A")
#reorder the levels so that the last level becomes baseline when used in lm
ins$zone
ins$make
levels(ins$zone)
levels(ins$make)
ins = read.csv("Insurance.csv", header = TRUE)
ins <- ins[ins$claims>0,]
ins$zone <- as.factor(ins$zone)
ins$make <- as.factor(ins$make)
levels(ins$zone)
levels(ins$make)
dim(ins)
head(ins)
pairs(ins)
ins.fit = lm(per ~ . , data = ins)
summary(ins.fit)
ins$zone
levels(ins$zone) <- c("B", "C", "D", "E", "F", "G", "A")
levels(ins$make) <- c("B", "C", "D", "E", "F", "G", "H", "I", "A")
#reorder the levels so that the last level becomes baseline when used in lm
levels(ins$zone)
levels(ins$make)
levels(ins$zone) <- c("B", "C", "D", "E", "F", "G", "A")
levels(ins$make) <- c("B", "C", "D", "E", "F", "G", "H", "I", "A")
#reorder the levels so that the last level becomes baseline when used in lm
levels(ins$zone)
levels(ins$make)
ins.fit.last = lm(per ~ . , data = ins)
summary(ins.fit)
ins = read.csv("Insurance.csv", header = TRUE)
ins <- ins[ins$claims>0,]
ins$zone <- as.factor(ins$zone)
ins$make <- as.factor(ins$make)
levels(ins$zone)
levels(ins$make)
dim(ins)
head(ins)
#pairs(ins)
ins.fit = lm(per ~ . , data = ins)
summary(ins.fit)
levels(ins$zone) <- c("B", "C", "D", "E", "F", "G", "A")
levels(ins$make) <- c("B", "C", "D", "E", "F", "G", "H", "I", "A")
#reorder the levels so that the last level becomes baseline when used in lm
levels(ins$zone)
levels(ins$make)
ins.fit.last = lm(per ~ . , data = ins)
summary(ins.fit)
?gl
?relevel
ins$zone <- relevel(ins$zone, ref = 7)
ins = read.csv("Insurance.csv", header = TRUE)
ins <- ins[ins$claims>0,]
ins$zone <- as.factor(ins$zone)
ins$make <- as.factor(ins$make)
levels(ins$zone)
levels(ins$make)
dim(ins)
head(ins)
#pairs(ins)
ins.fit = lm(per ~ . , data = ins)
summary(ins.fit)
ins$zone <- relevel(ins$zone, ref = 7)
ins$make <- relevel(ins$make, ref = 9)
#reorder the levels so that the last level becomes baseline when used in lm
levels(ins$zone)
levels(ins$make)
ins.fit.last = lm(per ~ . , data = ins)
summary(ins.fit)
ins$zone <- relevel(ins$zone, ref = 6)
ins$make <- relevel(ins$make, ref = 9)
#reorder the levels so that the last level becomes baseline when used in lm
levels(ins$zone)
levels(ins$make)
ins.fit.last = lm(per ~ . , data = ins)
summary(ins.fit)
ins$zone <- relevel(ins$zone, ref = 7)
ins$make <- relevel(ins$make, ref = 9)
#reorder the levels so that the last level becomes baseline when used in lm
levels(ins$zone)
levels(ins$make)
ins.fit.last = lm(per ~ . , data = ins)
summary(ins.fit)
ins = read.csv("Insurance.csv", header = TRUE)
ins <- ins[ins$claims>0,]
ins$zone <- as.factor(ins$zone)
ins$make <- as.factor(ins$make)
levels(ins$zone)
levels(ins$make)
dim(ins)
head(ins)
pairs(ins)
ins.fit = lm(per ~ . , data = ins)
summary(ins.fit)
ins$zone <- factor(ins$zone, levels = c(2,3,4,5,6,7,1))
ins$make <- factor(ins$make, levels = c(2,3,4,5,6,7,8,9,1))
#reorder the levels so that the last level becomes baseline when used in lm
levels(ins$zone)
levels(ins$make)
ins.fit.last = lm(per ~ . , data = ins)
summary(ins.fit)
11.186 - 2.862 + 1.459
