data.train <- filter(data.CV, fold != i)
data.valid <- filter(data.CV, fold == i)
### In tutorial, I was getting an error because I wrote -folds
### instead of -fold. Whoops!
data.train <- select(data.train, -fold)
data.valid <- select(data.valid, -fold)
fit.temp <- lm(Ozone ~ Temp, data = data.train)
fit.wind <- lm(Ozone ~ Wind, data = data.train)
fit.solar <- lm(Ozone ~ Solar.R, data = data.train)
fit.all <- lm(Ozone ~ Temp + Wind + Solar.R, data = data.train)
fit.intcurv <- lm(Ozone ~ Temp + Wind + Solar.R + I(Temp^2) + I(Wind^2) + I(Solar.R^2)
+ Temp*Wind + Temp*Solar.R + Wind*Solar.R, data = data.train)
pred.temp <- predict(fit.temp, data.valid)
pred.wind <- predict(fit.wind, data.valid)
pred.solar <- predict(fit.solar, data.valid)
pred.all <- predict(fit.all, data.valid)
pred.intcurv <- predict(fit.intcurv, data.valid)
Y.valid <- data.valid$Ozone
MSPE.temp <- get.MSPE(Y.valid, pred.temp)
MSPE.wind <- get.MSPE(Y.valid, pred.wind)
MSPE.solar <- get.MSPE(Y.valid, pred.solar)
MSPE.all <- get.MSPE(Y.valid, pred.all)
MSPE.intcurv <- get.MSPE(Y.valid, pred.intcurv)
CV.MSPEs[i, 1] <- MSPE.temp
CV.MSPEs[i, 2] <- MSPE.wind
CV.MSPEs[i, 3] <- MSPE.solar
CV.MSPEs[i, 4] <- MSPE.all
CV.MSPEs[i, 5] <- MSPE.intcurv
}
### We now have MSPEs for each fold of one iteration of CV. Let's
### get the average error across these folds (think of each fold
### as a data split), and store the result in ave.CV.MSPEs
this.ave.MSPEs <- apply(CV.MSPEs, 2, mean)
ave.CV.MSPEs[j, ] <- this.ave.MSPEs # We are replacing a whole
# row at once
}
boxplot(ave.CV.MSPEs,
main = "Boxplot of 20 Replicates of Average 5-Fold CV Error"
)
rel.ave.CV.MSPEs <- apply(ave.CV.MSPEs, 1, function(W) {
best <- min(W)
return(W / best)
})
rel.ave.CV.MSPEs <- t(rel.ave.CV.MSPEs)
boxplot(rel.ave.CV.MSPEs,
main = "Boxplot of 20 Replicates of Relative Average 5-Fold CV Error"
)
boxplot(ave.CV.MSPEs,
main = "Boxplot of 20 Replicates of Average 5-Fold CV Error"
)
rel.ave.CV.MSPEs <- apply(ave.CV.MSPEs, 1, function(W) {
best <- min(W)
return(W / best)
})
rel.ave.CV.MSPEs <- t(rel.ave.CV.MSPEs)
boxplot(rel.ave.CV.MSPEs,
main = "Boxplot of 20 Replicates of Relative Average 5-Fold CV Error"
)
boxplot(rel.ave.CV.MSPEs,
main = "Boxplot of 20 Replicates of Relative Average 5-Fold CV Error"
)
View(rel.ave.CV.MSPEs)
install.packages("faraway")
library(faraway)
Insurance
insurance = read.csv("Insurance.csv")
insurance = read.csv("Insurance.csv")
head(insurance)
remove(insurance)
ins = read.csv("Insurance.csv")
head(ins)
?read.csv
ins = read.csv("Insurance.csv", header = TRUE)
ins$zone <- as.factor(ins$zone)
ins$make <- as.factor(ins$make)
head(ins)
pairs(ins)
ins = read.csv("Insurance.csv", header = TRUE)
ins$zone <- as.factor(ins$zone)
ins$make <- as.factor(ins$make)
dim(ins)
head(ins)
pairs(ins)
boxplot(ins)
head(ins)
ins = read.csv("Insurance.csv", header = TRUE)
ins$zone <- as.factor(ins$zone)
ins$make <- as.factor(ins$make)
ins <- ins[ins$claims>0,]
dim(ins)
head(ins)
pairs(ins)
ins.fit = lm(per ~ ., data = ins)
summary(ins.fit)
ins.fit = lm(per ~ all, data = ins)
?lm
ins.fit = lm(per ~ . , data = ins)
summary(ins.fit)
levels(ins$zone)
levels(ins$make)
ins = read.csv("Insurance.csv", header = TRUE)
ins$zone <- as.factor(ins$zone)
ins$make <- as.factor(ins$make)
levels(ins$zone)
levels(ins$make)
ins <- ins[ins$claims>0,]
dim(ins)
head(ins)
pairs(ins)
levels(ins$zone)
# Here is how to see the information in the variable X1
class(dat$X1)
# Creating some data, saving to data frame, "dat"
set.seed(3894270)
X1 <- factor(rep(x = c("A", "B", "C", "D"), each = 5))
X2 <- round(rnorm(20), 2)
mean.y <- rep(c(3, 1, 5, 1), each = 5)
epsilon <- rnorm(20)
y <- round(mean.y + epsilon, 2)
dat <- data.frame(y, X1, X2)
# putting the columns of data side by side to make it easier to view
cbind(dat[1:5, ], dat[6:10, ], dat[11:15, ], dat[16:20, ])
# Here is how to see the information in the variable X1
class(dat$X1)
levels(dat$X1)
?levels
levels(ins$zone) <- c("B", "C", "D", "E", "F", "G", "A")
levels(ins$make) <- c("B", "C", "D", "E", "F", "G", "H", "I", "A")
levels(ins$zone) <- c("B", "C", "D", "E", "F", "G", "A")
levels(ins$make) <- c("B", "C", "D", "E", "F", "G", "H", "I", "A")
#reorder the levels so that the last level becomes baseline when used in lm
ins$zone
ins$make
levels(ins$zone)
levels(ins$make)
ins = read.csv("Insurance.csv", header = TRUE)
ins <- ins[ins$claims>0,]
ins$zone <- as.factor(ins$zone)
ins$make <- as.factor(ins$make)
levels(ins$zone)
levels(ins$make)
dim(ins)
head(ins)
pairs(ins)
ins.fit = lm(per ~ . , data = ins)
summary(ins.fit)
ins$zone
levels(ins$zone) <- c("B", "C", "D", "E", "F", "G", "A")
levels(ins$make) <- c("B", "C", "D", "E", "F", "G", "H", "I", "A")
#reorder the levels so that the last level becomes baseline when used in lm
levels(ins$zone)
levels(ins$make)
levels(ins$zone) <- c("B", "C", "D", "E", "F", "G", "A")
levels(ins$make) <- c("B", "C", "D", "E", "F", "G", "H", "I", "A")
#reorder the levels so that the last level becomes baseline when used in lm
levels(ins$zone)
levels(ins$make)
ins.fit.last = lm(per ~ . , data = ins)
summary(ins.fit)
ins = read.csv("Insurance.csv", header = TRUE)
ins <- ins[ins$claims>0,]
ins$zone <- as.factor(ins$zone)
ins$make <- as.factor(ins$make)
levels(ins$zone)
levels(ins$make)
dim(ins)
head(ins)
#pairs(ins)
ins.fit = lm(per ~ . , data = ins)
summary(ins.fit)
levels(ins$zone) <- c("B", "C", "D", "E", "F", "G", "A")
levels(ins$make) <- c("B", "C", "D", "E", "F", "G", "H", "I", "A")
#reorder the levels so that the last level becomes baseline when used in lm
levels(ins$zone)
levels(ins$make)
ins.fit.last = lm(per ~ . , data = ins)
summary(ins.fit)
?gl
?relevel
ins$zone <- relevel(ins$zone, ref = 7)
ins = read.csv("Insurance.csv", header = TRUE)
ins <- ins[ins$claims>0,]
ins$zone <- as.factor(ins$zone)
ins$make <- as.factor(ins$make)
levels(ins$zone)
levels(ins$make)
dim(ins)
head(ins)
#pairs(ins)
ins.fit = lm(per ~ . , data = ins)
summary(ins.fit)
ins$zone <- relevel(ins$zone, ref = 7)
ins$make <- relevel(ins$make, ref = 9)
#reorder the levels so that the last level becomes baseline when used in lm
levels(ins$zone)
levels(ins$make)
ins.fit.last = lm(per ~ . , data = ins)
summary(ins.fit)
ins$zone <- relevel(ins$zone, ref = 6)
ins$make <- relevel(ins$make, ref = 9)
#reorder the levels so that the last level becomes baseline when used in lm
levels(ins$zone)
levels(ins$make)
ins.fit.last = lm(per ~ . , data = ins)
summary(ins.fit)
ins$zone <- relevel(ins$zone, ref = 7)
ins$make <- relevel(ins$make, ref = 9)
#reorder the levels so that the last level becomes baseline when used in lm
levels(ins$zone)
levels(ins$make)
ins.fit.last = lm(per ~ . , data = ins)
summary(ins.fit)
ins = read.csv("Insurance.csv", header = TRUE)
ins <- ins[ins$claims>0,]
ins$zone <- as.factor(ins$zone)
ins$make <- as.factor(ins$make)
levels(ins$zone)
levels(ins$make)
dim(ins)
head(ins)
pairs(ins)
ins.fit = lm(per ~ . , data = ins)
summary(ins.fit)
ins$zone <- factor(ins$zone, levels = c(2,3,4,5,6,7,1))
ins$make <- factor(ins$make, levels = c(2,3,4,5,6,7,8,9,1))
#reorder the levels so that the last level becomes baseline when used in lm
levels(ins$zone)
levels(ins$make)
ins.fit.last = lm(per ~ . , data = ins)
summary(ins.fit)
11.186 - 2.862 + 1.459
remove(list=ls())
knitr::opts_chunk$set(echo = TRUE)
airquality
airquality[,1:4]
### This analysis will need some packages
### Note: no dplyr this time because it and MASS both have a function
###       called select()
library(MASS) # For ridge regression
library(glmnet) # For LASSO
### There were some functions we defined and used last week which
### made life easier. I've put them in a separate R script so we
### can give ourselves access to them without running all of last
### week's code.
source("Sec05_Tutorial_Helper.R")
### We are going to do CV, so we need to run set.seed()
set.seed(93425633)
### Read-in the data, and keep all predictors
source("Tutorials/Wine_Data_All.R")
### Let's define a function for constructing CV folds
get.folds <- function(n, K) {
### Get the appropriate number of fold labels
n.fold <- ceiling(n / K) # Number of observations per fold (rounded up)
fold.ids.raw <- rep(1:K, times = n.fold) # Generate extra labels
fold.ids <- fold.ids.raw[1:n] # Keep only the correct number of labels
### Shuffle the fold labels
folds.rand <- fold.ids[sample.int(n)]
return(folds.rand)
}
get.folds(5,10)
get.folds(6,10)
### Read-in the data, and keep all predictors
source("Wine_Data_All.R")
### Make a list of lambda values. The lm.ridge() function will
### then choose the best value from this list. Use the seq()
### function to create an equally-spaced list.
lambda.vals <- seq(from = 0, to = 100, by = 0.05)
prostate <- read.table("Datasets/Prostate.csv",
header = TRUE, sep = ",", na.strings = " "
)
prostate <- read.table("Prostate.csv",
header = TRUE, sep = ",", na.strings = " "
)
setwd("C:/Users/Terry Liu/Desktop/STAT 452/Class Examples")
prostate <- read.table("Prostate.csv",
header = TRUE, sep = ",", na.strings = " "
)
head(prostate)
set.seed(120401002)
set <- ifelse(runif(n = nrow(prostate)) > 0.5, yes = 2, no = 1)
library(MASS) # for ridge
library(glmnet) # for LASSO
AQ <- na.omit(airquality[,1:4])
AQ$TWcp = AQ$Temp*AQ$Wind
AQ$TWrat = AQ$Temp/AQ$Wind
library(MASS)
###############################################################
# Ridge regression using lm.ridge()
#
# Functions much like lm(), but need to specify lambda.
#   Can specify sequence of lambda values using seq(from= , to= , by=)
#     to generate sequence of numbers
#   Then use a version of CV to select best
seq(from = 1, to = 100, by = 0.05)
seq(1, 100, 0.05)
seq(0, 2, 0.2)
# In my experience, optimal lambda can be <1 sometimes
#   or as large as upper double digits.  Running sequence
#  from 0 to 100 by a small increment may be a little expensive
#  but probably covers range.
ridge1 <- lm.ridge(lpsa ~ ., lambda = seq(0, 100, .05),
data = prostate[set == 1, ])
# Show coefficient path
plot(ridge1)
# abline(h = 0, col = "red")
select(ridge1)
(coef.ri.best1 <- coef(ridge1)[which.min(ridge1$GCV), ])
# Unfortunately, there is no predict() function for lm.ridge
#  Have to compute predicted values manually using matrix multiplication
#  Formula is
#  as.matrix(cbind(1,DATA)) %*% coef(RIDGE MODEL)
#  where DATA is the X-data for which you want predicted values,
#  and RIDGE MODEL is the lm.ridge object you have created.
#  The "1" adds a column of 1's for the intercept term.
#
# Here I can use the optimal lambda to make predictions
#  on test data (set==2)
pred.ri1 <- as.matrix(cbind(1, prostate[set == 2, 1:8])) %*% coef.ri.best1
MSPE1.ridge <- mean((prostate[set == 2, 9] - pred.ri1)^2)
# Compare MSPE to MSPE from lm
mod.lm1 <- lm(lpsa ~ ., data = prostate[set == 1, ])
pred.lm1 <- predict(mod.lm1, newdata = prostate[set == 2, ])
MSPE1.lm <- mean((prostate[set == 2, 9] - pred.lm1)^2)
remove(list=ls())
setwd("C:/Users/Terry Liu/Desktop/STAT 452/Homework/hw_2")
###############################################################
# Ridge regression using lm.ridge()
#
# Functions much like lm(), but need to specify lambda.
#   Can specify sequence of lambda values using seq(from= , to= , by=)
#     to generate sequence of numbers
#   Then use a version of CV to select best
seq(from = 1, to = 100, by = 0.05)
seq(1, 100, 0.05)
AQ <- na.omit(airquality[,1:4])
AQ$TWcp = AQ$Temp*AQ$Wind
AQ$TWrat = AQ$Temp/AQ$Wind
library(MASS)
###############################################################
# Ridge regression using lm.ridge()
#
#  Running sequence from 0 to 100 by a small increment may be a little expensive
#  but probably covers range.
ridge1 <- lm.ridge(Ozone ~ ., lambda = seq(0, 100, .05), data = AQ)
# Show coefficient path
plot(ridge1)
abline(h = 0, col = "red")
# Show coefficient path
plot(ridge1)
abline(h = 0, col = "red")
# Show coefficient path
plot(ridge1)
AQ
AQ
plot(ridge1)
ridge1
select(ridge1)
(coef.ri.best1 <- coef(ridge1)[which.min(ridge1$GCV), ])
setwd("C:/Users/Terry Liu/Desktop/STAT 452/Class Examples")
prostate <- read.table("Prostate.csv",
header = TRUE, sep = ",", na.strings = " "
)
head(prostate)
head(AQ)
x = matrix(1:15, nrow = 3, ncol = 5)
x
x[,3:5]
AQ <- na.omit(airquality[,1:4])
AQ$TWcp = AQ$Temp*AQ$Wind
AQ$TWrat = AQ$Temp/AQ$Wind
head(AQ)
library(MASS)
###############################################################
# Ridge regression using lm.ridge()
#
#  Running sequence from 0 to 100 by a small increment may be a little expensive
#  but probably covers range.
ridge1 <- lm.ridge(Ozone ~ ., lambda = seq(0, 100, .05), data = AQ)
select(ridge1)
(coef.ri.best1 <- coef(ridge1)[which.min(ridge1$GCV), ])
pred.ri1 <- as.matrix(cbind(1, AQ[,2:6])) %*% coef.ri.best1
MSPE1.ridge <- mean((AQ[,7] - pred.ri1)^2)
AQ[,7]
AQ
pred.ri1 <- as.matrix(cbind(1, AQ[,2:6])) %*% coef.ri.best1
MSPE1.ridge <- mean((AQ[,1] - pred.ri1)^2)
pred.ri1
?select()
coef.ri.best1
as.matrix(cbind(1, AQ[,2:6]))
pred.ri1 <- as.matrix(cbind(1, prostate[set == 2, 1:8])) %*% coef.ri.best1
set <- ifelse(runif(n = nrow(prostate)) > 0.5, yes = 2, no = 1)
pred.ri1 <- as.matrix(cbind(1, prostate[set == 2, 1:8])) %*% coef.ri.best1
ridge1 <- lm.ridge(lpsa ~ ., lambda = seq(0, 100, .05),
data = prostate[set == 1, ])
# Show coefficient path
plot(ridge1)
# abline(h = 0, col = "red")
select(ridge1)
(coef.ri.best1 <- coef(ridge1)[which.min(ridge1$GCV), ])
# Unfortunately, there is no predict() function for lm.ridge
#  Have to compute predicted values manually using matrix multiplication
#  Formula is
#  as.matrix(cbind(1,DATA)) %*% coef(RIDGE MODEL)
#  where DATA is the X-data for which you want predicted values,
#  and RIDGE MODEL is the lm.ridge object you have created.
#  The "1" adds a column of 1's for the intercept term.
#
# Here I can use the optimal lambda to make predictions
#  on test data (set==2)
pred.ri1 <- as.matrix(cbind(1, prostate[set == 2, 1:8])) %*% coef.ri.best1
MSPE1.ridge <- mean((prostate[set == 2, 9] - pred.ri1)^2)
pred.ri1
AQ <- na.omit(airquality[,1:4])
AQ$TWcp = AQ$Temp*AQ$Wind
AQ$TWrat = AQ$Temp/AQ$Wind
head(AQ)
set <- ifelse(runif(n = nrow(AQ)) > 0.5, yes = 2, no = 1)
library(MASS)
###############################################################
# Ridge regression using lm.ridge()
#
#  Running sequence from 0 to 100 by a small increment may be a little expensive
#  but probably covers range.
ridge1 <- lm.ridge(Ozone ~ ., lambda = seq(0, 100, .05), data = AQ[set == 1,])
select(ridge1)
(coef.ri.best1 <- coef(ridge1)[which.min(ridge1$GCV), ])
coef.ri.best1
pred.ri1 <- as.matrix(cbind(1, AQ[set == 2, 2:6])) %*% coef.ri.best1
MSPE1.ridge <- mean((AQ[set == 2, 1] - pred.ri1)^2)
AQ <- na.omit(airquality[,1:4])
AQ$TWcp = AQ$Temp*AQ$Wind
AQ$TWrat = AQ$Temp/AQ$Wind
head(AQ)
set <- ifelse(runif(n = nrow(AQ)) > 0.5, yes = 2, no = 1)
library(MASS)
###############################################################
# Ridge regression using lm.ridge()
#
#  Running sequence from 0 to 100 by a small increment may be a little expensive
#  but probably covers range.
ridge1 <- lm.ridge(Ozone ~ ., lambda = seq(0, 100, .05), data = AQ[set == 1,])
select(ridge1)
(coef.ri.best1 <- coef(ridge1)[which.min(ridge1$GCV), ])
coef.ri.best1
pred.ri1 <- as.matrix(cbind(1, AQ[set == 2, 2:6])) %*% coef.ri.best1
MSPE1.ridge <- mean((AQ[set == 2, 1] - pred.ri1)^2)
# Compare MSPE to MSPE from lm
mod.lm1 <- lm(Ozone ~ ., data = AQ[set == 1, ])
pred.lm1 <- predict(mod.lm1, newdata = AQ[set == 2, ])
MSPE1.lm <- mean((AQ[set == 2, 1] - pred.lm1)^2)
remove(list=ls())
pred.lm1
AQ <- na.omit(airquality[,1:4])
AQ$TWcp = AQ$Temp*AQ$Wind
AQ$TWrat = AQ$Temp/AQ$Wind
head(AQ)
set <- ifelse(runif(n = nrow(AQ)) > 0.5, yes = 2, no = 1)
library(MASS)
###############################################################
# Ridge regression using lm.ridge()
#
#  Running sequence from 0 to 100 by a small increment may be a little expensive
#  but probably covers range.
ridge1 <- lm.ridge(Ozone ~ ., lambda = seq(0, 100, .05), data = AQ[set == 1,])
select(ridge1)
(coef.ri.best1 <- coef(ridge1)[which.min(ridge1$GCV), ])
coef.ri.best1
pred.ri1 <- as.matrix(cbind(1, AQ[set == 2, 2:6])) %*% coef.ri.best1
MSPE1.ridge <- mean((AQ[set == 2, 1] - pred.ri1)^2)
# Compare MSPE to MSPE from lm
mod.lm1 <- lm(Ozone ~ ., data = AQ[set == 1, ])
pred.lm1 <- predict(mod.lm1, newdata = AQ[set == 2, ])
MSPE1.lm <- mean((AQ[set == 2, 1] - pred.lm1)^2)
pred.ril
AQ <- na.omit(airquality[,1:4])
AQ$TWcp = AQ$Temp*AQ$Wind
AQ$TWrat = AQ$Temp/AQ$Wind
head(AQ)
set <- ifelse(runif(n = nrow(AQ)) > 0.5, yes = 2, no = 1)
library(MASS)
###############################################################
# Ridge regression using lm.ridge()
#
#  Running sequence from 0 to 100 by a small increment may be a little expensive
#  but probably covers range.
ridge1 <- lm.ridge(Ozone ~ ., lambda = seq(0, 100, .05), data = AQ[set == 1,])
select(ridge1)
(coef.ri.best1 <- coef(ridge1)[which.min(ridge1$GCV), ])
coef.ri.best1
pred.ri1 <- as.matrix(cbind(1, AQ[set == 2, 2:6])) %*% coef.ri.best1
MSPE1.ridge <- mean((AQ[set == 2, 1] - pred.ri1)^2)
# Compare MSPE to MSPE from lm
mod.lm1 <- lm(Ozone ~ ., data = AQ[set == 1, ])
pred.lm1 <- predict(mod.lm1, newdata = AQ[set == 2, ])
MSPE1.lm <- mean((AQ[set == 2, 1] - pred.lm1)^2)
pred.ri1
pred.lm1
pred.ril - t(pred.lm1)
pred.ri1 - t(pred.lm1)
dim(pred.lm1)
dim(pred.ri1)
length(pred.ri1)
length(pred.lm1)
pred.ri1 - pred.lm1
pred.lm1 - pred.ri1
which(pred.lm1 - pred.ri1)
?which
which(pred.lm1 - pred.ri1 < 0)
length(which(pred.lm1 - pred.ri1 > 0)) /length(pred.lm1)
pred.lm1 - pred.ri1
2^5
